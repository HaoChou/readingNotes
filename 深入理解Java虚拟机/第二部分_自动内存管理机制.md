
# 第三章 垃圾收集器与内存分配策略

## 对象已死吗
### 引用计数算法（不容易处理两个对象相互引用的场景）
### 可达性分析算法（GC_ROOTS)


## finalize方法

每个对象的finalize方法只会被系统自动调用一次

该类型如果涉及到IO资源的，可以重新实现finalize方法，比如在finalize方法里关闭外部资源。__不建议，代价高昂，不确定性大，无法保证各个对象的调用顺序，所以关闭资源还是用try-finally更好，更及时，所以忘记有这方法__




被废弃的配置项

UseCMSCompactAtFullCollection 
CMSFullGCsBeforeCompaction 
UseCMSCollectionPassing

https://bugs.openjdk.java.net/browse/JDK-8027132


The foreground collector in CMS has been deprecated and will likely be removed in a future release. It is recommended to use G1 or regular CMS instead.


codeCache

在jdk8中，提供了一个启动参数XX:+PrintCodeCache在jvm停止的时候打印出codeCache的使用情况。其中max_used就是在整个运行过程中codeCache的最大使用量。可以通过这个值来设置一个合理的codeCache大小，在保证应用正常运行的情况下减少内存使用。

UseCompressedOops 
oop 普通对象指针（ordinary object pointer）
Java堆中对象指针会被压缩成32位。 使用堆基地址（如果堆在低26G内存中的话，基地址为0）


UseCompressedClassPointers 选项来压缩类指针

【类指针】和【普通对象指针】 应该是两个概念

* 按字节编址 32位机器只有2的32次方的字节内存。32位系统 字长为32bit=4bye 按字节编址 最大内存 2^32*1byte=4GB  32根地址总线，每根总线上两种状态0或1，那么就可以有2^32个地址。
* 按字编址，64位机器中，一个字是8个字节。 32位按字编址后，最大内存是8byte*2^32 = 8*4GB= 32GB
？？地址最后三位为0。Java就利用通过移动（shifting）三位来达到扩大内存的并且实现compressed oops的目的。
                             
字长：计算机中对CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长
                             
HotSpot中 java对象由 对象头（header） 实例数据（Instance data） 对齐补充（padding） 组成
对象头=Mark word + class pointer（类型指针）


# 工具

## jps 虚拟机进程状况工具
JVM process status 类似于unix的ps

jps -q 只输出LVMID（local virtual machine identifier） 省略主类的名字
jps -m 输虚拟机启动时传递给主类main函数的参数
jps -l 输出主类的名称，如果进程执行的是Jar包，输出jar路径。
jps -v 输出虚拟机启动时的jvm参数

eg:
    jps -q |xargs pwdx 查看进程的启动路径
## jstat 虚拟机统计信息监控工具
JVM Statistics Monitoring Tool

 jstat -gc 24677 3000 100 监控进程24677 每3000毫秒一次 一共查询100次
 
 jstat -gc -t -h 10 24677 1000 一秒一次 10个位一个周期 会重新打表头 -t前面会有时间戳
 
  S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
 39296.0 39296.0 8259.3  0.0   314624.0 64561.4   655360.0   354617.1  120048.0 115614.9 12848.0 11976.3   2268   20.006  38      1.968   21.974
 39296.0 39296.0  0.0   6817.3 314624.0 76408.9   655360.0   354862.0  120048.0 115614.9 12848.0 11976.3   2269   20.016  38      1.968   21.984
 39296.0 39296.0 5665.6  0.0   314624.0 34937.5   655360.0   355191.1  120048.0 115614.9 12848.0 11976.3   2270   20.023  38      1.968   21.992
 39296.0 39296.0 5665.6  0.0   314624.0 149113.8  655360.0   355191.1  120048.0 115614.9 12848.0 11976.3   2270   20.023  38      1.968   21.992
 
    S0C：第一个幸存区的大小
    S1C：第二个幸存区的大小
    S0U：第一个幸存区的使用大小
    S1U：第二个幸存区的使用大小
    EC：伊甸园区的大小
    EU：伊甸园区的使用大小
    OC：老年代大小
    OU：老年代使用大小
    MC：方法区大小
    MU：方法区使用大小
    CCSC:压缩类空间大小
    CCSU:压缩类空间使用大小
    YGC：年轻代垃圾回收次数
    YGCT：年轻代垃圾回收消耗时间
    FGC：老年代垃圾回收次数
    FGCT：老年代垃圾回收消耗时间
    GCT：垃圾回收消耗总时间
 